#include "generate/generator_cs.h"
#include "generator.h"
#include "version.h"
#include "symbols.h"

#include <stdio.h>
#include <string.h>
#include <assert.h>


static error_code_t on_document_begin(generator_t *super, const YYLTYPE *yylloc, const char *file_name)
{
	char header[MAX_PACKAGE_NAME_LENGTH];	
	TDR_UNUSED(yylloc);

	generator_open(super, file_name, GENERATOR_CS_SUFFIX);

	generator_printline(super, 0, "/**");
    generator_printline(super, 0, " * Autogenerated by %s Compiler (%s)", PROJECT_NAME, VERSION);
    generator_printline(super, 0, " *");
    generator_printline(super, 0, " * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING");
    generator_printline(super, 0, " *  @generated");
    generator_printline(super, 0, " */");
	generator_printline(super, 0, "");

	
	//包含header的头文件
	strncpy(header, file_name, MAX_PACKAGE_NAME_LENGTH);
	header[MAX_PACKAGE_NAME_LENGTH - 1] = 0;
	generator_replace_extension(header, MAX_PACKAGE_NAME_LENGTH, GENERATOR_CS_SUFFIX);
	generator_printline(super, 0, "using System;");
	generator_printline(super, 0, "using TLibCS.Protocol;");
	generator_printline(super, 0, "");
	generator_printline(super, 0, "namespace TLibCS.Creation");
	generator_printline(super, 0, "{");

	generator_printline(super, 0, "");
	return E_TD_NOERROR;
}

static error_code_t on_document_end(generator_t *super, const YYLTYPE *yylloc, const char *file_name)
{
	TDR_UNUSED(file_name);
	TDR_UNUSED(yylloc);

	generator_printline(super, 0, "}");
	generator_printline(super, 0, "");

	generator_close(super);
	return E_TD_NOERROR;
}

static error_code_t _on_const(generator_cs_t *self, const syn_const_t *de_const)
{
	generator_printline(&self->super, 1, "public static partial class Constants");
	generator_printline(&self->super, 1, "{");
	generator_print(&self->super, 2, "public const ");
	generator_print_cstype(&self->super, &de_const->type);
	generator_print(&self->super, 0, " %s = ", de_const->identifier);
	generator_print_value(&self->super, &de_const->val);
	generator_printline(&self->super, 2, ";");
	generator_printline(&self->super, 1, "}");

	return E_TD_NOERROR;
}

static error_code_t _on_enum(generator_cs_t *self, const syn_enum_t *de_enum)
{
	uint32_t i;

	generator_printline(&self->super, 0, "");
	generator_printline(&self->super, 1, "public enum %s", de_enum->name);
	generator_printline(&self->super, 1, "{");
	for(i = 0; i < de_enum->enum_def_list_num; ++i)
	{
		generator_print(&self->super, 2, "%s = ", de_enum->enum_def_list[i].identifier);
		generator_print_value(&self->super, &de_enum->enum_def_list[i].val);
		generator_print(&self->super, 0, ",");
		if(de_enum->enum_def_list[i].comment.text[0])
		{
			generator_print(&self->super, 0, "//%s", de_enum->enum_def_list[i].comment.text);
		}
		generator_printline(&self->super, 0, "");
	}
	
	generator_printline(&self->super, 1, "};");
	generator_printline(&self->super, 0, "");

	return E_TD_NOERROR;
}

static void print_struct_header(generator_cs_t *self, const char *name, const syn_field_list_t *field_list)
{
	size_t i;

	generator_printline(&self->super, 1, "public partial class %s", name);
	generator_printline(&self->super, 1, "{");
	for(i = 0; i < field_list->field_list_num; ++i)
	{
		const syn_field_t *field = &field_list->field_list[i];
		const syn_simple_type_t *st = NULL;
		

		if(field->type.type == E_SNT_CONTAINER)
		{
			if(field->type.ct.ct == E_CT_VECTOR)
			{
				generator_print(&self->super, 2, "private ");
				generator_print_cstype(&self->super, &g_vec_num_type);
				generator_print(&self->super, 0, " _"VEC_NUM_TYPE_STYLE";", field->identifier);
				generator_printline(&self->super, 0, "");
				st = &field->type.ct.vector_type;
			}
		}
		else
		{
			st = &field->type.st;
		}
		st = symbols_get_real_type(self->super.symbols, st);

		generator_print(&self->super, 2, "private ");
		generator_print_cstype(&self->super, st);
		if(field->type.type == E_SNT_CONTAINER)
		{
			if(field->type.ct.ct == E_CT_VECTOR)
			{
				generator_print(&self->super, 2, "[]");			
			}
		}
		generator_print(&self->super, 0, " _%s;", field->identifier);
		if(field->comment.text[0])
		{
			generator_print(&self->super, 0, " //%s", field->comment.text);
		}

		generator_printline(&self->super, 0, "");


		generator_print(&self->super, 2, "public ");
		generator_print_cstype(&self->super, st);
		if(field->type.type == E_SNT_CONTAINER)
		{
			if(field->type.ct.ct == E_CT_VECTOR)
			{
				generator_print(&self->super, 2, "[]");			
			}
		}
		generator_printline(&self->super, 0, " %s", field->identifier);

		generator_printline(&self->super, 2, "{");
		generator_printline(&self->super, 3, "get { return _%s; }", field->identifier);
		generator_printline(&self->super, 3, "set { _%s = value; }", field->identifier);
		generator_printline(&self->super, 2, "}");
		generator_printline(&self->super, 0, "");

	}
}

static void _on_struct_write(generator_cs_t *self, const syn_struct_t *de_struct)
{
	uint32_t i, j;

	generator_printline(&self->super, 2, "public void Write(TWriter writer)", de_struct->name, de_struct->name);
	generator_printline(&self->super, 2, "{");
	generator_printline(&self->super, 2, "");
	generator_printline(&self->super, 3, "writer.WriteStructBegin(\"%s\");", de_struct->name);

	for(i = 0; i < de_struct->field_list.field_list_num; ++i)
	{
		//condition
		if(de_struct->field_list.field_list[i].condition.oper != E_EO_NON)
		{
			const char *op = NULL;
			switch(de_struct->field_list.field_list[i].condition.oper)
			{
			case E_EO_AND:
				op = "&";		
				break;
			case E_EO_EQUAL:		
				op = "==";
				break;
			case E_EO_UNEQUAL:
				op = "!=";
				break;
			default:
				assert(0);
			}
			generator_print(&self->super, 3, "if(this.%s %s ", de_struct->field_list.field_list[i].condition.op0, op);
			if(de_struct->field_list.field_list[i].condition.op1.type == E_SNVT_REFER)
			{
				generator_print(&self->super, 0, "Constants.");
			}
			generator_print_value(&self->super, &de_struct->field_list.field_list[i].condition.op1);
			generator_printline(&self->super, 0, ")");
			generator_printline(&self->super, 3, "{");
		}
		else
		{
			generator_printline(&self->super, 3, "{");
		}


		if(de_struct->field_list.field_list[i].type.type == E_SNT_CONTAINER)
		{
			if(de_struct->field_list.field_list[i].type.ct.ct == E_CT_VECTOR)
			{
				const syn_simple_type_t *st = symbols_get_real_type(self->super.symbols, &de_struct->field_list.field_list[i].type.ct.vector_type);
				const symbol_t* refer_type = NULL;

				generator_printline(&self->super, 4, "writer.WriteVectorBegin();");
				generator_printline(&self->super, 0, "");

				generator_printline(&self->super, 4, "if (writer.WriteFieldBegin(\""VEC_NUM_TYPE_STYLE"\"))", de_struct->field_list.field_list[i].identifier);
				generator_printline(&self->super, 4, "{");
				generator_print(&self->super, 5, "this._"VEC_NUM_TYPE_STYLE" = (", de_struct->field_list.field_list[i].identifier);
				generator_print_cstype(&self->super, &g_vec_num_type);
				generator_printline(&self->super, 0, ")this._%s.Length;", de_struct->field_list.field_list[i].identifier);
				generator_printline(&self->super, 5, "writer.Write(this._"VEC_NUM_TYPE_STYLE");", de_struct->field_list.field_list[i].identifier);
				generator_printline(&self->super, 4, "}");
				generator_printline(&self->super, 4, "writer.WriteFieldEnd(\""VEC_NUM_TYPE_STYLE"\");", de_struct->field_list.field_list[i].identifier);

				generator_printline(&self->super, 0, "");

				generator_printline(&self->super, 4, "for(uint i = 0; i < Constants.%s; ++i)", de_struct->field_list.field_list[i].type.ct.vector_length);
				generator_printline(&self->super, 4, "{");				
				generator_printline(&self->super, 5, "if(i == this._"VEC_NUM_TYPE_STYLE") break;", de_struct->field_list.field_list[i].identifier);
				generator_printline(&self->super, 0, "");
				generator_printline(&self->super, 5, "if(writer.WriteVectorElementBegin(\"%s\", i))", de_struct->field_list.field_list[i].identifier);
				generator_printline(&self->super, 5, "{");
				if(st->st == E_ST_REFER)
				{
					refer_type = symbols_search(self->super.symbols, "", st->st_refer);
					if(refer_type->type != EN_HST_ENUM)
					{
						generator_print(&self->super, 6, "this._%s[i].Write(writer", de_struct->field_list.field_list[i].identifier);
						for(j = 0; j < de_struct->field_list.field_list[i].args.arg_list_num; ++j)
						{
							generator_print(&self->super, 0, ", this.%s", de_struct->field_list.field_list[i].args.arg_list[j]);
						}
						generator_printline(&self->super, 4, ");");
					}
					else
					{
						generator_printline(&self->super, 6, "writer.Write((int)this._%s[i]);", de_struct->field_list.field_list[i].identifier);
					}					
				}
				else
				{
					generator_printline(&self->super, 6, "writer.Write(this._%s[i]);", de_struct->field_list.field_list[i].identifier);
				}				
				generator_printline(&self->super, 5, "}");

				if(st->st == E_ST_REFER)
				{
					if(refer_type->type == EN_HST_ENUM)
					{
						generator_printline(&self->super, 5, "else");
						generator_printline(&self->super, 5, "{");
						generator_printline(&self->super, 6, "writer.Write(this._%s.ToString());", de_struct->field_list.field_list[i].identifier);
						generator_printline(&self->super, 5, "}");
					}
				}
			

				generator_printline(&self->super, 5, "writer.WriteVectorElementEnd(\"%s\", i);", de_struct->field_list.field_list[i].identifier);
				generator_printline(&self->super, 4, "}");
				generator_printline(&self->super, 4, "writer.WriteVectorEnd();");
			}
		}
		else if(de_struct->field_list.field_list[i].type.type == E_SNT_SIMPLE)
		{
			const syn_simple_type_t *st = symbols_get_real_type(self->super.symbols, &de_struct->field_list.field_list[i].type.st);
			const symbol_t* refer_type = NULL;

			generator_printline(&self->super, 4, "if(writer.WriteFieldBegin(\"%s\"))", de_struct->field_list.field_list[i].identifier);
			generator_printline(&self->super, 4, "{");
			if(st->st == E_ST_REFER)
			{
				refer_type = symbols_search(self->super.symbols, "", st->st_refer);
				if(refer_type->type != EN_HST_ENUM)
				{
					generator_print(&self->super, 5, "this._%s.Write(writer", de_struct->field_list.field_list[i].identifier);
					for(j = 0; j < de_struct->field_list.field_list[i].args.arg_list_num; ++j)
					{
						generator_print(&self->super, 0, ", this.%s", de_struct->field_list.field_list[i].args.arg_list[j]);
					}
					generator_printline(&self->super, 4, ");");
				}
				else
				{
					generator_printline(&self->super, 5, "writer.Write((int)this._%s);", de_struct->field_list.field_list[i].identifier);
				}
			}
			else
			{
				generator_printline(&self->super, 5, "writer.Write(this._%s);", de_struct->field_list.field_list[i].identifier);
			}
			generator_printline(&self->super, 4, "}");

			if(st->st == E_ST_REFER)
			{
				if(refer_type->type == EN_HST_ENUM)
				{
					generator_printline(&self->super, 4, "else");
					generator_printline(&self->super, 4, "{");
					generator_printline(&self->super, 5, "writer.Write(this._%s.ToString());", de_struct->field_list.field_list[i].identifier);
					generator_printline(&self->super, 4, "}");
				}
			}
			generator_printline(&self->super, 4, "writer.WriteFieldEnd(\"%s\");", de_struct->field_list.field_list[i].identifier);
		}

		generator_printline(&self->super, 3, "}");//end of condition;
		generator_printline(&self->super, 0, "");
	}
	generator_printline(&self->super, 0, "");
	generator_printline(&self->super, 3, "writer.WriteStructEnd(\"%s\");", de_struct->name);

	generator_printline(&self->super, 2, "}");
}


static void _on_struct_read(generator_cs_t *self, const syn_struct_t *de_struct)
{
	uint32_t i, j;

	generator_printline(&self->super, 2, "public void Read(TReader reader)");
	generator_printline(&self->super, 2, "{");
	generator_printline(&self->super, 0, "");
	generator_printline(&self->super, 3, "reader.ReadStructBegin(\"%s\");", de_struct->name);

	for(i = 0; i < de_struct->field_list.field_list_num; ++i)
	{		
		//condition
		if(de_struct->field_list.field_list[i].condition.oper != E_EO_NON)
		{
			const char *op = NULL;
			switch(de_struct->field_list.field_list[i].condition.oper)
			{
			case E_EO_AND:
				op = "&";		
				break;
			case E_EO_EQUAL:		
				op = "==";
				break;
			case E_EO_UNEQUAL:
				op = "!=";
				break;
			default:
				assert(0);
			}
			generator_print(&self->super, 3, "if(this.%s %s ", de_struct->field_list.field_list[i].condition.op0, op);
			if(de_struct->field_list.field_list[i].condition.op1.type == E_SNVT_REFER)
			{
				generator_print(&self->super, 0, "Constants.");
			}
			generator_print_value(&self->super, &de_struct->field_list.field_list[i].condition.op1);
			generator_printline(&self->super, 0, ")");
			generator_printline(&self->super, 3, "{");
		}
		else
		{
			generator_printline(&self->super, 3, "{");
		}


		if(de_struct->field_list.field_list[i].type.type == E_SNT_CONTAINER)
		{
			if(de_struct->field_list.field_list[i].type.ct.ct == E_CT_VECTOR)
			{
				const syn_simple_type_t *st = symbols_get_real_type(self->super.symbols, &de_struct->field_list.field_list[i].type.ct.vector_type);
				const symbol_t* refer_type = NULL;

				generator_printline(&self->super, 4, "reader.ReadVectorBegin();");
				generator_printline(&self->super, 0, "");

				generator_printline(&self->super, 4, "if (reader.ReadFieldBegin(\""VEC_NUM_TYPE_STYLE"\"))", de_struct->field_list.field_list[i].identifier);
				generator_printline(&self->super, 4, "{");
				generator_printline(&self->super, 5, "reader.Read(out this._"VEC_NUM_TYPE_STYLE");", de_struct->field_list.field_list[i].identifier);
				generator_print(&self->super, 5, "this._%s = new ", de_struct->field_list.field_list[i].identifier);
				generator_print_cstype(&self->super, st);
				generator_printline(&self->super, 0, "[this._"VEC_NUM_TYPE_STYLE"];", de_struct->field_list.field_list[i].identifier);

				generator_printline(&self->super, 4, "}");
				generator_printline(&self->super, 4, "reader.ReadFieldEnd(\""VEC_NUM_TYPE_STYLE"\");", de_struct->field_list.field_list[i].identifier);

				generator_printline(&self->super, 0, "");

				generator_printline(&self->super, 4, "for(uint i = 0; i < Constants.%s; ++i)", de_struct->field_list.field_list[i].type.ct.vector_length);
				generator_printline(&self->super, 4, "{");
				generator_printline(&self->super, 5, "if(i == this._"VEC_NUM_TYPE_STYLE") break;", de_struct->field_list.field_list[i].identifier);
				generator_printline(&self->super, 0, "");
				generator_printline(&self->super, 5, "if(reader.ReadVectorElementBegin(\"%s\", i))", de_struct->field_list.field_list[i].identifier);
				generator_printline(&self->super, 5, "{");
				if(st->st == E_ST_REFER)
				{
					refer_type = symbols_search(self->super.symbols, "", st->st_refer);
					if(refer_type->type != EN_HST_ENUM)
					{
						generator_printline(&self->super, 5, "this._%s[i] = new %s();", de_struct->field_list.field_list[i].identifier, st->st_refer);
						generator_print(&self->super, 5, "this._%s[i].Read(reader", de_struct->field_list.field_list[i].identifier);
						for(j = 0; j < de_struct->field_list.field_list[i].args.arg_list_num; ++j)
						{
							generator_print(&self->super, 0, ", this.%s", de_struct->field_list.field_list[i].args.arg_list[j]);
						}
						generator_printline(&self->super, 4, ");");
					}
					else
					{
						generator_printline(&self->super, 6, "int e;");
						generator_printline(&self->super, 6, "reader.Read(out e);", de_struct->field_list.field_list[i].identifier);
						generator_printline(&self->super, 6, "this._%s[i] = (%s)e;", de_struct->field_list.field_list[i].identifier, refer_type->body.symbol_enum.name);
					}
				}
				else
				{
					generator_printline(&self->super, 6, "reader.Read(out this._%s[i]);", de_struct->field_list.field_list[i].identifier);
				}
				generator_printline(&self->super, 5, "}");
				if(st->st == E_ST_REFER)
				{
					if(refer_type->type == EN_HST_ENUM)
					{
						generator_printline(&self->super, 5, "else");
						generator_printline(&self->super, 5, "{");
						generator_printline(&self->super, 6, "string es;");						
						generator_printline(&self->super, 6, "reader.Read(out es);");
						generator_printline(&self->super, 6, "this._%s = (%s)Enum.Parse(typeof(%s), es);", de_struct->field_list.field_list[i].identifier, refer_type->body.symbol_enum.name, refer_type->body.symbol_enum.name);
						generator_printline(&self->super, 5, "}");
					}
				}
				generator_printline(&self->super, 5, "reader.ReadVectorElementEnd(\"%s\", i);", de_struct->field_list.field_list[i].identifier);
				generator_printline(&self->super, 4, "}");
				generator_printline(&self->super, 4, "reader.ReadVectorEnd();");
			}
		}
		else if(de_struct->field_list.field_list[i].type.type == E_SNT_SIMPLE)
		{
			const syn_simple_type_t *st = symbols_get_real_type(self->super.symbols, &de_struct->field_list.field_list[i].type.st);
			const symbol_t* refer_type = NULL;
			generator_printline(&self->super, 4, "if(reader.ReadFieldBegin(\"%s\"))", de_struct->field_list.field_list[i].identifier);
			generator_printline(&self->super, 4, "{");
			if(st->st == E_ST_REFER)
			{
				refer_type = symbols_search(self->super.symbols, "", st->st_refer);
				if(refer_type->type != EN_HST_ENUM)
				{
					generator_print(&self->super, 5, "this._%s.Read(reader", de_struct->field_list.field_list[i].identifier);
					for(j = 0; j < de_struct->field_list.field_list[i].args.arg_list_num; ++j)
					{
						generator_print(&self->super, 0, ", this.%s", de_struct->field_list.field_list[i].args.arg_list[j]);
					}
					generator_printline(&self->super, 4, ");");
				}
				else
				{
					generator_printline(&self->super, 6, "int e;");
					generator_printline(&self->super, 6, "reader.Read(out e);", de_struct->field_list.field_list[i].identifier);
					generator_printline(&self->super, 6, "this._%s = (%s)e;", de_struct->field_list.field_list[i].identifier, refer_type->body.symbol_enum.name);
				}
			}
			else
			{
				generator_printline(&self->super, 5, "reader.Read(out this._%s);", de_struct->field_list.field_list[i].identifier);
			}
			generator_printline(&self->super, 4, "}");
			if(st->st == E_ST_REFER)
			{
				if(refer_type->type == EN_HST_ENUM)
				{
					generator_printline(&self->super, 4, "else");
					generator_printline(&self->super, 4, "{");
					generator_printline(&self->super, 5, "string es;");						
					generator_printline(&self->super, 5, "reader.Read(out es);");
					generator_printline(&self->super, 5, "this._%s = (%s)Enum.Parse(typeof(%s), es);", de_struct->field_list.field_list[i].identifier, refer_type->body.symbol_enum.name, refer_type->body.symbol_enum.name);
					generator_printline(&self->super, 4, "}");
				}
			}
			generator_printline(&self->super, 4, "reader.ReadFieldEnd(\"%s\");", de_struct->field_list.field_list[i].identifier);
		}

		generator_printline(&self->super, 3, "}");//end of condition;
		generator_printline(&self->super, 0, "");
	}
	generator_printline(&self->super, 0, "");
	generator_printline(&self->super, 3, "reader.ReadStructEnd(\"%s\");", de_struct->name);

	generator_printline(&self->super, 2, "}");
}




static error_code_t _on_struct(generator_cs_t *self, const syn_struct_t *de_struct)
{
	print_struct_header(self, de_struct->name, &de_struct->field_list);

	_on_struct_read(self, de_struct);
	generator_printline(&self->super, 0, "");
	_on_struct_write(self, de_struct);
	generator_printline(&self->super, 1, "}");
	generator_printline(&self->super, 0, "");

	return E_TD_NOERROR;
}


static void print_union_header(generator_cs_t *self, const char *name, const syn_union_field_list_t *union_field_list)
{
	size_t i;

	generator_printline(&self->super, 1, "public partial class %s", name);
	generator_printline(&self->super, 1, "{");
	for(i = 0; i < union_field_list->union_field_list_num; ++i)
	{
		const syn_union_field_t *field = &union_field_list->union_field_list[i];
		const syn_simple_type_t *st = symbols_get_real_type(self->super.symbols, &field->simple_type);

		generator_print(&self->super, 2, "private ");


		generator_print_cstype(&self->super, st);
		generator_print(&self->super, 0, " _%s;", field->name);
		if(field->comment.text[0])
		{
			generator_print(&self->super, 0, " //%s", field->comment.text);
		}

		generator_printline(&self->super, 0, "");


		generator_print(&self->super, 2, "public ");
		generator_print_cstype(&self->super, st);
		generator_printline(&self->super, 0, " %s", field->name);

		generator_printline(&self->super, 2, "{");
		generator_printline(&self->super, 3, "get { return _%s; }", field->name);
		generator_printline(&self->super, 3, "set { _%s = value; }", field->name);
		generator_printline(&self->super, 2, "}");
		generator_printline(&self->super, 0, "");

	}
}

static void _on_union_write(generator_cs_t *self, const syn_union_t *de_union)
{
	uint32_t i;
	generator_printline(&self->super, 2, "public void Write(TWriter writer, %s selector)", de_union->parameters.par_list[0].type.st_refer);
	generator_printline(&self->super, 2, "{");
	generator_printline(&self->super, 3, "writer.WriteUnionBegin(\"%s\");", de_union->name);
	generator_printline(&self->super, 3, "switch(selector)");
	generator_printline(&self->super, 3, "{");
	for(i = 0; i < de_union->union_field_list.union_field_list_num; ++i)
	{
		const syn_simple_type_t *st = symbols_get_real_type(self->super.symbols, &de_union->union_field_list.union_field_list[i].simple_type);
		const symbol_t* refer_type = NULL;
		generator_printline(&self->super, 3, "case %s.%s:", de_union->parameters.par_list[0].type.st_refer, de_union->union_field_list.union_field_list[i].key);
		generator_printline(&self->super, 4, "if(writer.WriteFieldBegin(\"%s\"))", de_union->union_field_list.union_field_list[i].name);
		generator_printline(&self->super, 4, "{");
		if(st->st == E_ST_REFER)
		{
			refer_type = symbols_search(self->super.symbols, "", st->st_refer);
			if(refer_type->type != EN_HST_ENUM)
			{
				generator_printline(&self->super, 5, "this._%s.Write(writer);", de_union->union_field_list.union_field_list[i].name);
			}
			else
			{
				generator_printline(&self->super, 5, "writer.Write((int)this._%s);", de_union->union_field_list.union_field_list[i].name);
			}			
		}
		else
		{
			generator_printline(&self->super, 5, "writer.Write(this._%s);", de_union->union_field_list.union_field_list[i].name);
		}
		generator_printline(&self->super, 4, "}");
		if(st->st == E_ST_REFER)
		{
			if(refer_type->type == EN_HST_ENUM)
			{
				generator_printline(&self->super, 4, "else");
				generator_printline(&self->super, 4, "{");
				generator_printline(&self->super, 5, "writer.Write(this._%s.ToString());", de_union->union_field_list.union_field_list[i].name);
				generator_printline(&self->super, 4, "}");
			}
		}

		generator_printline(&self->super, 4, "writer.WriteFieldEnd(\"%s\");", de_union->union_field_list.union_field_list[i].name);
		generator_printline(&self->super, 4, "break;");		
	}
	generator_printline(&self->super, 3, "default:");
	generator_printline(&self->super, 4, "break;");		
	generator_printline(&self->super, 3, "}");
	generator_printline(&self->super, 3, "writer.WriteUnionEnd(\"%s\");", de_union->name);

	generator_printline(&self->super, 2, "}");
}

static void _on_union_read(generator_cs_t *self, const syn_union_t *de_union)
{
	uint32_t i;
	generator_printline(&self->super, 2, "public void Read(TReader reader, %s selector)", de_union->parameters.par_list[0].type.st_refer);
	generator_printline(&self->super, 2, "{");
	generator_printline(&self->super, 3, "reader.ReadUnionBegin(\"%s\");", de_union->name);
	generator_printline(&self->super, 3, "switch(selector)");
	generator_printline(&self->super, 3, "{");
	for(i = 0; i < de_union->union_field_list.union_field_list_num; ++i)
	{
		const syn_simple_type_t *st = symbols_get_real_type(self->super.symbols, &de_union->union_field_list.union_field_list[i].simple_type);
		const symbol_t* refer_type = NULL;

		generator_printline(&self->super, 3, "case %s.%s:", de_union->parameters.par_list[0].type.st_refer, de_union->union_field_list.union_field_list[i].key);
		generator_printline(&self->super, 4, "if(reader.ReadFieldBegin(\"%s\"))", de_union->union_field_list.union_field_list[i].name);
		generator_printline(&self->super, 4, "{");
		if(st->st == E_ST_REFER)
		{
			refer_type = symbols_search(self->super.symbols, "", st->st_refer);
			if(refer_type->type != EN_HST_ENUM)
			{
				generator_printline(&self->super, 5, "this._%s = new %s();", de_union->union_field_list.union_field_list[i].name, st->st_refer);
				generator_printline(&self->super, 5, "this._%s.Read(reader);", de_union->union_field_list.union_field_list[i].name, st->st_refer);
			}
			else
			{
				generator_printline(&self->super, 6, "int e;");
				generator_printline(&self->super, 6, "reader.Read(out e);", de_union->union_field_list.union_field_list[i].name);
				generator_printline(&self->super, 6, "this._%s = (%s)e;", de_union->union_field_list.union_field_list[i].name, refer_type->body.symbol_enum.name);
			}			
		}
		else
		{
			generator_printline(&self->super, 5, "reader.Read(out this._%s);", de_union->union_field_list.union_field_list[i].name);
		}
		generator_printline(&self->super, 4, "}");
		if(st->st == E_ST_REFER)
		{
			if(refer_type->type == EN_HST_ENUM)
			{
				generator_printline(&self->super, 4, "else");
				generator_printline(&self->super, 4, "{");
				generator_printline(&self->super, 5, "string es;");						
				generator_printline(&self->super, 5, "reader.Read(out es);");
				generator_printline(&self->super, 5, "this._%s = (%s)Enum.Parse(typeof(%s), es);", de_union->union_field_list.union_field_list[i].name, refer_type->body.symbol_enum.name, refer_type->body.symbol_enum.name);
				generator_printline(&self->super, 4, "}");
			}
		}
		generator_printline(&self->super, 4, "reader.ReadFieldEnd(\"%s\");", de_union->union_field_list.union_field_list[i].name);
		generator_printline(&self->super, 4, "break;");		
	}
	generator_printline(&self->super, 3, "default:");
	generator_printline(&self->super, 4, "break;");		
	generator_printline(&self->super, 3, "}");
	generator_printline(&self->super, 3, "reader.ReadUnionEnd(\"%s\");", de_union->name);

	generator_printline(&self->super, 2, "}");
}

static error_code_t _on_union(generator_cs_t *self, const syn_union_t *de_union)
{	
	print_union_header(self, de_union->name, &de_union->union_field_list);
	
	_on_union_read(self, de_union);
	generator_printline(&self->super, 0, "");
	_on_union_write(self, de_union);
	generator_printline(&self->super, 1, "}");	
	generator_printline(&self->super, 0, "");

	return E_TD_NOERROR;
}

static error_code_t _on_unix_comment(generator_cs_t *self, const syn_unix_comment_t *de_unix_comment)
{
	generator_printline(&self->super, 0, "//%s", de_unix_comment->text);
	return E_TD_NOERROR;
}

static error_code_t on_definition(generator_t *super, const YYLTYPE *yylloc, const syn_definition_t *definition)
{
	generator_cs_t *self = TDR_CONTAINER_OF(super, generator_cs_t, super);
	TDR_UNUSED(yylloc);
	switch(definition->type)
	{
		case E_DT_CONST:
			return _on_const(self, &definition->definition.de_const);
		case E_DT_ENUM:
			return _on_enum(self, &definition->definition.de_enum);
		case E_DT_STRUCT:
			return _on_struct(self, &definition->definition.de_struct);
		case E_DT_UNION:
			return _on_union(self, &definition->definition.de_union);
		case E_DT_TYPEDEF:
			return E_TD_NOERROR;
		case E_DT_UNIX_COMMENT:
			return _on_unix_comment(self, &definition->definition.de_unix_comment);
		default:
			return E_TD_ERROR;
	}
}

void generator_cs_init(generator_cs_t *self, const symbols_t *symbols)
{
	generator_init(&self->super, symbols);

	self->super.on_document_begin = on_document_begin;
	self->super.on_document_end = on_document_end;
	self->super.on_definition = on_definition;
}
